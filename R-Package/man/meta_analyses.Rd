% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/meta_analyses.R
\name{meta_analyses}
\alias{meta_analyses}
\title{Meta Analyses}
\usage{
meta_analyses(
  data,
  output_folder = NULL,
  suppress_list_output = FALSE,
  method = "REML",
  sparse = FALSE
)
}
\arguments{
\item{data}{The function expects the input to be a data frame. The input may either be the data frame produced by the MetaPipeX::merge_replication_summaries() function, or one with the same columns names. A template of this data frame is available on \href{https://github.com/JensFuenderich/MetaPipeX/blob/main/Supplementary_Material/Table_Templates/3_Merged_Replication_Summaries/Merged_Replication_Summaries_template.csv}{{github}}, as is a \href{https://github.com/JensFuenderich/MetaPipeX/blob/main/Supplementary_Material/Table_Templates/3_Merged_Replication_Summaries/codebook_for_merged_replication_summeries.csv}{{codebook}} for unambiguous identification of the abbreviations. Further, it is possible to use a \href{INSERT LINK}{{reduced version of the codebook}}, as meta-analyses are applied to MD and SMD only.}

\item{output_folder}{Specify the output folder for the replication summaries and the codebook. If no folder is specified, the function will return its output only to the R environment (unless this is suppressed under suppress_list_output).}

\item{suppress_list_output}{A logical indicating whether results should be returned in R. If TRUE, no output is returned in R.}

\item{method}{A character string to specify the type of model to be fitted. Default is “REML”. For more details, refer to the \href{https://www.metafor-project.org/doku.php/help}{{metafor}}  documentation.}

\item{sparse}{A logical indicating whether sparse matrices should be used.}
}
\value{
The output is a list with two objects: A data frame with the meta-analytical results and a codebook for unambiguous identification of its columns. \cr
\cr ## meta analyses \cr
The data frame contains information to identify each analysis (MultiLab, ReplicationProject) and statistical output from the two meta-analyses per replication project. The statistical output for each meta-analysis includes:
\itemize{
\item{A model estimate for the y of interest (Est__).}
\item{The number of replications included in the analysis (Result__K).}
\item{The estimated \mjeqn{\tau^2}{} (sigma2 from the rma.mv object) value (Tau2__).}
\item{The estimated \mjeqn{\tau}{} (the square root of the sigma2 from the rma.mv object) value (Tau2__).}
\item{The estimated \mjeqn{I^2}{} value. \mjeqn{I^2}{} is not part of the rma.mv output object and has to be calculated from \mjeqn{\tau}{}.
\mjdeqn{ I^2 = 100 \frac{ \hat{\tau}^2  }{ \hat{\tau}^2 + \tilde{v}} }{}
with
\mjdeqn{ \tilde{v} = \frac{(k-1)\sum w_{i}}{\left(\sum  w_{i}\right)-\sum w_{i}^2} }{}
Transformation according to: https://wviechtb.github.io/metafor/reference/print.rma.html
}
\item{The estimated \mjeqn{H^2}{} value. \mjeqn{H^2}{} is not part of the rma.mv output object and has to be calculated from \mjeqn{\tau}{}.
\mjdeqn{ H^2 = 100 \frac{ \hat{\tau}^2 + \tilde{v} }{\tilde{v}} }{}
with
\mjdeqn{ \tilde{v} = \frac{(k-1)\sum w_{i}}{\left(\sum  w_{i}\right)-\sum w_{i}^2} }{}
}
\item{The Q statistic (QE__).}
\item{The p-value from the test on the Q statistic (QEp__).}
}
## codebook \cr
A codebook that applies to the data frame (meta_analyses).
}
\description{
\loadmathjax{}
\(
\\let\\underscore_
\)
Function to run meta-analyses on the mean difference (MD) and the standardized mean difference (SMD). The meta-analyses are run with the metafor::rma.mv function (Viechtbauer, 2010). For more details on the meta-analyses, refer to the Details and Return section. This function is the third (and fifth computational step) of the MetaPipeX pipeline. For more details on the pipeline, refer to the documentation of the MetaPipeX-package.
}
\details{
The meta-analyses within the function are written with metafor::rma.mv (Viechtbauer, 2010). The multivariate version of the rma function is deployed to allow for the use of sparse matrices (“sparse = TRUE”) for optimal performance in meta-analyses with thousands of replications. They are fitted as a random-effects model with “random = ~ 1 | Replication” and a restricted maximum likelihood estimation (“REML”).
The function runs two meta-analyses per replication project:
\itemize{
 \item{mean difference (yi = MD, sei = SE_MD)}
 \item{standardized mean difference (yi = SMD, sei = SE_SMD)}
 }
}
\examples{

# import the according table template
Merged_Replication_Summaries_template <- readr::read_csv(url(
paste("https://raw.githubusercontent.com/JensFuenderich/MetaPipeX/main/Supplementary_Material/",
"Table_Templates/3_Merged_Replication_Summaries/Merged_Replication_Summaries_template.csv",
sep = "")
))

# set seed for drawing data
set.seed(1973)

# create vectors with names
MultiLab_names <- c("MultiLab_1", "MultiLab_1", "MultiLab_2",  "MultiLab_2")
ReplicationProject_names <- c("Effect_A", "Effect_B", "Effect_C", "Effect_D")
Replication_names <- c("Lab_A", "Lab_B", "Lab_C", "Lab_D", "Lab_E", "Lab_F", "Lab_G", "Lab_H")


# random sampling for simulated data & building identifier variables
list_of_replication_summaries <- lapply(1:4, function(x){
  # sampling
  data_example <- as.data.frame(matrix(
  data = stats::rnorm(n = 200*(ncol(Merged_Replication_Summaries_template)-3), mean = 5, sd = 0.5),
  nrow = 200,
  ncol = ncol(Merged_Replication_Summaries_template)-3)
  )
  # rename columns according to template
  names(data_example) <- names(
  Merged_Replication_Summaries_template
  )[4:length(names(Merged_Replication_Summaries_template))]
  data_example$T_N <- round(data_example$T_N, 0)
  data_example$T_N <- round(data_example$C_N, 0)
  # building identifier variables
  MultiLab <- rep(MultiLab_names[x], times = nrow(data_example))
  ReplicationProject <- rep(ReplicationProject_names[x], times = nrow(data_example))
  Replication <- rep(if (x == 1 | x == 2) {
  Replication_names[1:4]
  } else if (x == 3 | x == 4) {
  Replication_names[5:8]
  }, each = nrow(data_example)/4)
  # combine data & identifiers
  cbind(MultiLab, ReplicationProject, Replication, data_example)
})

# merge list object
merged_replication_summaries <- rbind(list_of_replication_summaries[[1]],
                                      list_of_replication_summaries[[2]],
                                      list_of_replication_summaries[[3]],
                                      list_of_replication_summaries[[4]])


## applying the input to the MetaPipeX function

# run merge_replication_summaries
example_MetaPipeX_output <- MetaPipeX::meta_analyses(data = merged_replication_summaries)

\dontrun{
All examples with additional comments are available on github:
https://github.com/JensFuenderich/MetaPipeX/tree/main/Supplementary_Material/Code_Examples
}

}
\references{
Viechtbauer, W. (2010). Conducting meta-analyses in R with the metafor package. Journal of Statistical Software, 36(3), 1-48. doi: 10.18637/jss.v036.i03
}
